use anyhow::Result;
use std::collections::HashSet;
use std::sync::Arc;
use crate::schema;

pub type Pair = (Arc<schema::Type>, Arc<schema::Type>);

/// An algorithm to determine whether a pair of types belongs to a relation.
///
/// The relation is defined by the function `step_f(pair, goals)`, which, for a given `pair`,
/// either returns `Err` to signal that `pair` is not a member of the relation, or it returns `Ok`
/// and adds to `goals` the pairs that are in the relation if and only if `pair` is in the
/// relation.
///
/// This algorithm automatically unwraps typedefs, so `step_f` does not need to handle
/// [`Type::Typedef`][schema::Type::Typedef].
///
/// Intuitively, this algorithm is just a depth first search through a directed graph over `Pair`-s
/// generated by the `step_f` from `goal`, which checks whether `step_f` returns `Ok` for all
/// reachable pairs in the graph.
///
/// Formally, this algorithm determines whether the `goal` belongs to a set _X_ defined as the
/// greatest fixed point of generating function _F_ which is the inverse of `step_f`. (For details
/// about the mathematical formulation, see chapter 21 from "Types and Programming Languages" by B.
/// Pierce).
pub fn evaluate_relation<StepF>(
    schema_a: &schema::Schema,
    schema_b: &schema::Schema,
    goal: Pair,
    mut step_f: StepF
) -> Result<()>
    where StepF: FnMut(Pair, &mut Vec<Pair>) -> Result<()>
{
    let mut assumptions: HashSet<Pair> = HashSet::new();
    let mut goals: Vec<Pair> = vec![goal];

    while let Some(goal) = goals.pop() {
        if !assumptions.insert(goal.clone()) {
            continue;
        }

        let (goal_a, goal_b) = goal;

        if let Some(goal_deref_a) = deref_typedef(schema_a, &goal_a) {
            goals.push((goal_deref_a, goal_b));
            continue;
        }
        if let Some(goal_deref_b) = deref_typedef(schema_b, &goal_b) {
            goals.push((goal_a, goal_deref_b));
            continue;
        }

        step_f((goal_a, goal_b), &mut goals)?;
    }

    Ok(())
}

fn deref_typedef(schema: &schema::Schema, type_: &schema::Type) -> Option<Arc<schema::Type>> {
    if let schema::Type::Typedef(type_name) = type_ {
        Some(schema.typedefs[type_name].clone())
    } else {
        None
    }
}
